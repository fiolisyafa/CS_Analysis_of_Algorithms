from lexer import Lexer
import re

#SYNTAX ANALYZER


# A list of non-terminals is defined in order to allow us to identify non-terminals from terminals when we go through the production rules in the grammar.

nonterminal = ['S', 'Expr', 'Ident', 'Expr\'']

grammar = '''
	S : Expr
	Expr : TAGS Ident Expr'
	Expr : LPAREN Expr RPAREN Expr'
	Expr' : CHILD Expr
	Expr' : SIBLING Expr
	Expr' : TIMES DIGIT Expr'
	Expr' : POW Expr
	Expr' : LBRACE TEXT RBRACE Expr'
	Expr' : e
	Ident : CLASS
	Ident : ID
	Ident : e
'''

# Syntax Analyzer class will check whether the tokens generated by the Lexer are placed correctly based on the grammar.
class SyntaxAnalyzer(object):
	def __init__(self, text):
	    self.text = text
	    self.lexer = Lexer

	def check_syntax(self):
		# A symbol 'þ' is concatenated to the input text to mark the end of the string.
		text = self.text
		text += 'þ'
		lex = self.lexer(text)
		lex.currentToken = lex.getNextToken()

		# The grammar gets split by newlines and tabs before being stored in a list. The list then contains each line of grammar as a list item. This list item then gets split by whitespace, creating a list inside of a list.
		syn_grammar = [i.split() for i in list(filter(None, re.split('\n|\t', grammar)))]

		# A stack is used to keep track of the production rule being used. The EOF symbol 'þ' is pushed first followed by the Start symbol 'S'.
		stack = []
		stack.append('þ')
		stack.append('S')

		# Popping from the stack gives the Start symbol 'S' as the current grammar.
		currentGrammar = stack.pop()

		# The following loop continues for as long as the grammar popped from the stack is not the EOF symbol.
		while currentGrammar != 'þ':
			# With 'syn_grammar' being the list containing lists, 'syn' is the list item. The list item here being one line of grammar. Since each list item is also a list, 'syn[0]' is a non-terminal, 'syn[0]' is the colon, and 'syn[2]' and onwards are the rest of the production rule.
			for syn in syn_grammar:
				# If the production of the current grammar is empty
				if currentGrammar == syn[0] and syn[2] == 'e':
					break

				# If the current grammar is a non-terminal
				elif currentGrammar in nonterminal and currentGrammar == syn[0]:

					# If 'syn[2]' (first item after the colon) is a terminal but does not match the type of the token, move to the next production of the grammar
					if syn[2] not in nonterminal and syn[2] != lex.currentToken.type:
						continue

					# If the terminal matches the type of the current token, push the entire production rule from the back (the end up to before the colon) into the stack.
					for prod in syn[-1:1:-1]:
						stack.append(prod)

					break

				# If the current grammar popped from the stack is a terminal
				elif currentGrammar not in nonterminal:
					#If the terminal is empty
					if currentGrammar == 'e':
						continue
					# If the terminal matches the type of current token, move on to the next token.
					elif currentGrammar == lex.currentToken.type:
						lex.currentToken = lex.getNextToken()
					break

				# If the parser has reached the last production rule but still does not make a match, then it is a syntax error.
				elif syn_grammar.index(syn)  == len(syn_grammar) - 1:
					print("Error")
					return 0

			# Pop from the stack to get the next grammar
			currentGrammar = stack.pop()

		# If the parsing is completed
		print("Success")
		return 1
